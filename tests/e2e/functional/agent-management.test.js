/**
 * Tests fonctionnels - Gestion des agents
 */

const TestEnvironment = require('../setup/test-environment');
const TestHelpers = require('../../utils/test-helpers');
const testConfig = require('../../config/test-config');

class AgentManagementTests {
  constructor() {
    this.environment = new TestEnvironment();
    this.helpers = new TestHelpers(testConfig);
    this.results = [];
    this.testAgents = [];
  }

  /**
   * Ex√©cuter tous les tests de gestion des agents
   */
  async runAllTests() {
    this.helpers.log('ü§ñ D√©marrage des tests de gestion des agents...', 'INFO');

    try {
      // Initialiser l'environnement
      await this.environment.initialize();

      // Ex√©cuter les tests
      await this.testAgentCreation();
      await this.testAgentRetrieval();
      await this.testAgentUpdate();
      await this.testAgentDeletion();
      await this.testAgentValidation();
      await this.testAgentPermissions();
      await this.testAgentExecution();

      // G√©n√©rer le rapport
      const report = this.generateReport();
      this.helpers.log('‚úÖ Tests de gestion des agents termin√©s', 'INFO');
      
      return report;

    } catch (error) {
      this.helpers.log(`‚ùå Erreur lors des tests: ${error.message}`, 'ERROR');
      throw error;
    } finally {
      await this.cleanup();
    }
  }

  /**
   * Test de cr√©ation d'agents
   */
  async testAgentCreation() {
    this.helpers.log('‚ûï Test de cr√©ation d\'agents...', 'INFO');

    const testAgents = [
      {
        name: 'Test Assistant',
        description: 'Agent assistant de test',
        role: 'assistant',
        model: testConfig.services.ollama.model,
        tools: ['rag.search', 'fs.read'],
        permissions: {
          network: false,
          files: true,
          tools: ['rag.search', 'fs.read']
        }
      },
      {
        name: 'Test Researcher',
        description: 'Agent chercheur de test',
        role: 'researcher',
        model: testConfig.services.ollama.model,
        tools: ['rag.search', 'web.fetch'],
        permissions: {
          network: true,
          files: false,
          tools: ['rag.search', 'web.fetch']
        }
      },
      {
        name: 'Test Writer',
        description: 'Agent √©crivain de test',
        role: 'writer',
        model: testConfig.services.ollama.model,
        tools: ['fs.write', 'rag.answer'],
        permissions: {
          network: false,
          files: true,
          tools: ['fs.write', 'rag.answer']
        }
      }
    ];

    for (const agentData of testAgents) {
      try {
        const response = await fetch(`${testConfig.services.worker.baseUrl}/agents`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(agentData)
        });

        if (response.ok) {
          const createdAgent = await response.json();
          this.testAgents.push(createdAgent);

          this.recordResult(`Cr√©ation agent: ${agentData.name}`, {
            success: true,
            details: `Agent cr√©√© avec ID: ${createdAgent.id}`,
            data: createdAgent
          });
          this.helpers.log(`‚úÖ Agent cr√©√©: ${agentData.name}`, 'INFO');
        } else {
          const error = await response.text();
          this.recordResult(`Cr√©ation agent: ${agentData.name}`, {
            success: false,
            error: `HTTP ${response.status}: ${error}`
          });
          this.helpers.log(`‚ùå √âchec cr√©ation: ${agentData.name}`, 'ERROR');
        }
      } catch (error) {
        this.recordResult(`Cr√©ation agent: ${agentData.name}`, {
          success: false,
          error: error.message
        });
        this.helpers.log(`‚ùå Erreur cr√©ation: ${agentData.name} - ${error.message}`, 'ERROR');
      }
    }
  }

  /**
   * Test de r√©cup√©ration d'agents
   */
  async testAgentRetrieval() {
    this.helpers.log('üìã Test de r√©cup√©ration d\'agents...', 'INFO');

    const tests = [
      {
        name: 'Liste tous les agents',
        test: async () => {
          const response = await fetch(`${testConfig.services.worker.baseUrl}/agents`);
          if (response.ok) {
            const agents = await response.json();
            return { success: true, count: agents.length, agents };
          } else {
            return { success: false, error: `HTTP ${response.status}` };
          }
        }
      },
      {
        name: 'R√©cup√©ration par ID',
        test: async () => {
          if (this.testAgents.length === 0) {
            return { success: false, error: 'Aucun agent de test disponible' };
          }

          const agent = this.testAgents[0];
          const response = await fetch(`${testConfig.services.worker.baseUrl}/agents/${agent.id}`);
          if (response.ok) {
            const retrievedAgent = await response.json();
            return { success: true, agent: retrievedAgent };
          } else {
            return { success: false, error: `HTTP ${response.status}` };
          }
        }
      },
      {
        name: 'Filtrage par r√¥le',
        test: async () => {
          const response = await fetch(`${testConfig.services.worker.baseUrl}/agents?role=assistant`);
          if (response.ok) {
            const agents = await response.json();
            return { success: true, count: agents.length, role: 'assistant' };
          } else {
            return { success: false, error: `HTTP ${response.status}` };
          }
        }
      }
    ];

    for (const test of tests) {
      try {
        const result = await test.test();
        this.recordResult(`R√©cup√©ration: ${test.name}`, {
          success: result.success,
          details: result.success ? test.name : result.error,
          data: result
        });

        if (result.success) {
          this.helpers.log(`‚úÖ ${test.name}: Succ√®s`, 'INFO');
        } else {
          this.helpers.log(`‚ùå ${test.name}: ${result.error}`, 'ERROR');
        }
      } catch (error) {
        this.recordResult(`R√©cup√©ration: ${test.name}`, {
          success: false,
          error: error.message
        });
        this.helpers.log(`‚ùå ${test.name}: ${error.message}`, 'ERROR');
      }
    }
  }

  /**
   * Test de mise √† jour d'agents
   */
  async testAgentUpdate() {
    this.helpers.log('‚úèÔ∏è Test de mise √† jour d\'agents...', 'INFO');

    if (this.testAgents.length === 0) {
      this.helpers.log('‚ö†Ô∏è Aucun agent disponible pour les tests de mise √† jour', 'WARN');
      return;
    }

    const agent = this.testAgents[0];
    const updateData = {
      name: `${agent.name} (Mis √† jour)`,
      description: `${agent.description} - Mise √† jour de test`,
      tools: [...agent.tools, 'math.evaluate'],
      permissions: {
        ...agent.permissions,
        tools: [...agent.permissions.tools, 'math.evaluate']
      }
    };

    try {
      const response = await fetch(`${testConfig.services.worker.baseUrl}/agents/${agent.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updateData)
      });

      if (response.ok) {
        const updatedAgent = await response.json();
        
        // V√©rifier que les modifications ont √©t√© appliqu√©es
        const isUpdated = 
          updatedAgent.name === updateData.name &&
          updatedAgent.description === updateData.description &&
          updatedAgent.tools.includes('math.evaluate');

        this.recordResult('Mise √† jour agent', {
          success: isUpdated,
          details: isUpdated ? 'Agent mis √† jour avec succ√®s' : 'Mise √† jour incompl√®te',
          data: updatedAgent
        });

        if (isUpdated) {
          this.helpers.log('‚úÖ Agent mis √† jour avec succ√®s', 'INFO');
        } else {
          this.helpers.log('‚ùå Mise √† jour incompl√®te', 'ERROR');
        }
      } else {
        const error = await response.text();
        this.recordResult('Mise √† jour agent', {
          success: false,
          error: `HTTP ${response.status}: ${error}`
        });
        this.helpers.log(`‚ùå √âchec mise √† jour: ${error}`, 'ERROR');
      }
    } catch (error) {
      this.recordResult('Mise √† jour agent', {
        success: false,
        error: error.message
      });
      this.helpers.log(`‚ùå Erreur mise √† jour: ${error.message}`, 'ERROR');
    }
  }

  /**
   * Test de suppression d'agents
   */
  async testAgentDeletion() {
    this.helpers.log('üóëÔ∏è Test de suppression d\'agents...', 'INFO');

    if (this.testAgents.length === 0) {
      this.helpers.log('‚ö†Ô∏è Aucun agent disponible pour les tests de suppression', 'WARN');
      return;
    }

    // Supprimer le dernier agent cr√©√©
    const agentToDelete = this.testAgents[this.testAgents.length - 1];

    try {
      const response = await fetch(`${testConfig.services.worker.baseUrl}/agents/${agentToDelete.id}`, {
        method: 'DELETE'
      });

      if (response.ok) {
        // V√©rifier que l'agent a bien √©t√© supprim√©
        const checkResponse = await fetch(`${testConfig.services.worker.baseUrl}/agents/${agentToDelete.id}`);
        const isDeleted = checkResponse.status === 404;

        this.recordResult('Suppression agent', {
          success: isDeleted,
          details: isDeleted ? 'Agent supprim√© avec succ√®s' : 'Agent toujours pr√©sent',
          data: { deletedId: agentToDelete.id }
        });

        if (isDeleted) {
          this.helpers.log('‚úÖ Agent supprim√© avec succ√®s', 'INFO');
          this.testAgents.pop(); // Retirer de la liste
        } else {
          this.helpers.log('‚ùå Agent toujours pr√©sent apr√®s suppression', 'ERROR');
        }
      } else {
        const error = await response.text();
        this.recordResult('Suppression agent', {
          success: false,
          error: `HTTP ${response.status}: ${error}`
        });
        this.helpers.log(`‚ùå √âchec suppression: ${error}`, 'ERROR');
      }
    } catch (error) {
      this.recordResult('Suppression agent', {
        success: false,
        error: error.message
      });
      this.helpers.log(`‚ùå Erreur suppression: ${error.message}`, 'ERROR');
    }
  }

  /**
   * Test de validation des agents
   */
  async testAgentValidation() {
    this.helpers.log('‚úÖ Test de validation des agents...', 'INFO');

    const invalidAgents = [
      {
        name: '', // Nom vide
        description: 'Agent avec nom vide',
        role: 'assistant',
        model: testConfig.services.ollama.model
      },
      {
        name: 'Agent sans mod√®le',
        description: 'Agent sans mod√®le sp√©cifi√©',
        role: 'assistant'
        // Pas de mod√®le
      },
      {
        name: 'Agent avec outils invalides',
        description: 'Agent avec outils qui n\'existent pas',
        role: 'assistant',
        model: testConfig.services.ollama.model,
        tools: ['invalid.tool', 'another.invalid']
      },
      {
        name: 'Agent avec permissions invalides',
        description: 'Agent avec permissions contradictoires',
        role: 'assistant',
        model: testConfig.services.ollama.model,
        permissions: {
          network: false,
          files: false,
          tools: ['web.fetch'] // Outil r√©seau sans permission r√©seau
        }
      }
    ];

    for (const invalidAgent of invalidAgents) {
      try {
        const response = await fetch(`${testConfig.services.worker.baseUrl}/agents`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(invalidAgent)
        });

        // Un agent invalide devrait √™tre rejet√©
        const isValidRejection = response.status === 400 || response.status === 422;

        this.recordResult(`Validation: ${invalidAgent.name || 'Agent sans nom'}`, {
          success: isValidRejection,
          details: isValidRejection ? 'Validation correcte' : 'Validation √©chou√©e',
          data: { status: response.status }
        });

        if (isValidRejection) {
          this.helpers.log(`‚úÖ Validation correcte pour: ${invalidAgent.name || 'Agent sans nom'}`, 'INFO');
        } else {
          this.helpers.log(`‚ùå Validation √©chou√©e pour: ${invalidAgent.name || 'Agent sans nom'}`, 'ERROR');
        }
      } catch (error) {
        this.recordResult(`Validation: ${invalidAgent.name || 'Agent sans nom'}`, {
          success: false,
          error: error.message
        });
        this.helpers.log(`‚ùå Erreur validation: ${error.message}`, 'ERROR');
      }
    }
  }

  /**
   * Test des permissions des agents
   */
  async testAgentPermissions() {
    this.helpers.log('üîê Test des permissions des agents...', 'INFO');

    if (this.testAgents.length === 0) {
      this.helpers.log('‚ö†Ô∏è Aucun agent disponible pour les tests de permissions', 'WARN');
      return;
    }

    const agent = this.testAgents[0];

    const permissionTests = [
      {
        name: 'V√©rification permissions r√©seau',
        test: async () => {
          const hasNetworkPermission = agent.permissions?.network === true;
          return { success: true, hasNetwork: hasNetworkPermission };
        }
      },
      {
        name: 'V√©rification permissions fichiers',
        test: async () => {
          const hasFilePermission = agent.permissions?.files === true;
          return { success: true, hasFiles: hasFilePermission };
        }
      },
      {
        name: 'V√©rification outils autoris√©s',
        test: async () => {
          const allowedTools = agent.permissions?.tools || [];
          const hasValidTools = allowedTools.length > 0;
          return { success: true, tools: allowedTools, hasValidTools };
        }
      },
      {
        name: 'Validation coh√©rence permissions',
        test: async () => {
          const hasNetworkTools = agent.tools.some(tool => tool.startsWith('web.'));
          const hasNetworkPermission = agent.permissions?.network === true;
          const isConsistent = !hasNetworkTools || hasNetworkPermission;
          
          return { 
            success: isConsistent, 
            hasNetworkTools, 
            hasNetworkPermission, 
            isConsistent 
          };
        }
      }
    ];

    for (const test of permissionTests) {
      try {
        const result = await test.test();
        this.recordResult(`Permissions: ${test.name}`, {
          success: result.success,
          details: test.name,
          data: result
        });

        if (result.success) {
          this.helpers.log(`‚úÖ ${test.name}: Succ√®s`, 'INFO');
        } else {
          this.helpers.log(`‚ùå ${test.name}: Incoh√©rence d√©tect√©e`, 'ERROR');
        }
      } catch (error) {
        this.recordResult(`Permissions: ${test.name}`, {
          success: false,
          error: error.message
        });
        this.helpers.log(`‚ùå ${test.name}: ${error.message}`, 'ERROR');
      }
    }
  }

  /**
   * Test d'ex√©cution des agents
   */
  async testAgentExecution() {
    this.helpers.log('‚ñ∂Ô∏è Test d\'ex√©cution des agents...', 'INFO');

    if (this.testAgents.length === 0) {
      this.helpers.log('‚ö†Ô∏è Aucun agent disponible pour les tests d\'ex√©cution', 'WARN');
      return;
    }

    const agent = this.testAgents[0];
    const testMessage = {
      content: 'Bonjour, pouvez-vous me dire qui vous √™tes ?',
      sender: 'user',
      timestamp: new Date().toISOString()
    };

    try {
      const response = await fetch(`${testConfig.services.worker.baseUrl}/agents/${agent.id}/execute`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: testMessage })
      });

      if (response.ok) {
        const result = await response.json();
        
        const isValidResponse = 
          result.success &&
          result.response &&
          result.response.content &&
          result.response.agentId === agent.id;

        this.recordResult('Ex√©cution agent', {
          success: isValidResponse,
          details: isValidResponse ? 'Agent ex√©cut√© avec succ√®s' : 'R√©ponse invalide',
          data: {
            agentId: agent.id,
            hasResponse: !!result.response,
            responseLength: result.response?.content?.length || 0
          }
        });

        if (isValidResponse) {
          this.helpers.log('‚úÖ Agent ex√©cut√© avec succ√®s', 'INFO');
        } else {
          this.helpers.log('‚ùå R√©ponse d\'ex√©cution invalide', 'ERROR');
        }
      } else {
        const error = await response.text();
        this.recordResult('Ex√©cution agent', {
          success: false,
          error: `HTTP ${response.status}: ${error}`
        });
        this.helpers.log(`‚ùå √âchec ex√©cution: ${error}`, 'ERROR');
      }
    } catch (error) {
      this.recordResult('Ex√©cution agent', {
        success: false,
        error: error.message
      });
      this.helpers.log(`‚ùå Erreur ex√©cution: ${error.message}`, 'ERROR');
    }
  }

  /**
   * Nettoyage des donn√©es de test
   */
  async cleanup() {
    this.helpers.log('üßπ Nettoyage des agents de test...', 'INFO');

    // Supprimer tous les agents de test cr√©√©s
    for (const agent of this.testAgents) {
      try {
        await fetch(`${testConfig.services.worker.baseUrl}/agents/${agent.id}`, {
          method: 'DELETE'
        });
        this.helpers.log(`üóëÔ∏è Agent supprim√©: ${agent.name}`, 'INFO');
      } catch (error) {
        this.helpers.log(`‚ö†Ô∏è Erreur suppression agent ${agent.name}: ${error.message}`, 'WARN');
      }
    }

    this.testAgents = [];
  }

  /**
   * Enregistrer un r√©sultat de test
   */
  recordResult(testName, result) {
    this.results.push({
      testName,
      result,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * G√©n√©rer le rapport de test
   */
  generateReport() {
    const totalTests = this.results.length;
    const passedTests = this.results.filter(r => r.result.success).length;
    const failedTests = totalTests - passedTests;
    const successRate = (passedTests / totalTests) * 100;

    const report = {
      summary: {
        total: totalTests,
        passed: passedTests,
        failed: failedTests,
        successRate: `${successRate.toFixed(2)}%`
      },
      results: this.results,
      timestamp: new Date().toISOString()
    };

    this.helpers.log(`üìä Rapport: ${passedTests}/${totalTests} tests r√©ussis (${successRate.toFixed(2)}%)`, 'INFO');
    
    if (failedTests > 0) {
      this.helpers.log(`‚ùå ${failedTests} tests ont √©chou√©:`, 'ERROR');
      this.results.filter(r => !r.result.success).forEach(r => {
        this.helpers.log(`  - ${r.testName}: ${r.result.error || '√âchec'}`, 'ERROR');
      });
    }

    return report;
  }
}

module.exports = AgentManagementTests;
